---
title: "risk set matching analysis "
output: 
  html_document:
  code_folding: hide
editor_options: 
  chunk_output_type: console
---

# Setup, load packages
```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(knitr)
library(rsmatch)
library(survival)
library(nbpMatching)
library(MatchIt)
```

```{r}
setwd("/Users/emma/Desktop/local_only/mind_study")

adt_long <- read_csv("./adt_long.csv")
adt_long_patients <- read_csv("./adt_long_patients.csv")
covid_long <- read_csv("./covid_long.csv")
micro_long <- read_csv("./micro_long.csv")
micro_long_positives_only <- read_csv("./micro_long_positives_only.csv")
patients <- read_csv("./patients.csv", col_types = cols(hospice_dt = col_datetime(format = "")))
bacterial_infections <- read_csv("./bacterial_infections.csv")
covid_admissions_bacterial <- read_csv("./covid_admissions_bacterial.csv")
```

Most of the following code is also in the mind_exploratory rmd file. Revisit questions about how many covid admissions each patient has and how many bacterial infections each patient has occuring during covid admissions:
```{r}
# how many "covid admissions" does each patient have?
adt_long_patients %>% 
  group_by(mrn) %>% 
  summarize(n_covid_admissions = sum(covid_admission)) %>% 
  ungroup() %>% 
  group_by(n_covid_admissions) %>% 
  summarize(n = n()) %>% 
  kable()

# How many infections did each covid patient have that occurred during covid inpatient admissions?
covid_admissions_bacterial %>% 
  group_by(mrn) %>% 
  summarize(n_bacterial_infections = sum(bacterial_infection)) %>% 
  ungroup() %>%  group_by(n_bacterial_infections) %>% 
  summarize(n = n()) %>% 
  kable()
    # >1 means multiple infections 

# How many unique mrns are there?
covid_admissions_bacterial %>%  count(mrn)

# examine details of covid admissions for patients with multiple covid admissions:
adt_long_patients %>% 
  group_by(mrn) %>% 
  mutate(n_covid_admissions = sum(covid_admission)) %>% 
  filter(n_covid_admissions > 1,
         covid_admission == T) %>% 
  select(mrn, adt_inpatient_dt, adt_discharge_dt, adt_site, adt_care_level, adt_discharge_disp) %>% 
  view()
```
It seems that these multiple inpatients stays either have to do with transfer to a different care level (ICU, hospice, etc), 
or with multiple stays that are initiated by emergency room visits with the week following covid diagnosis.
I may want to look for transfers to ICU care that happen later in the trajectory for patients with covid admissions - 
ie, if they were admitted and then transferred and the transfer shows up as a different line.

Try the example given with the rsmatch package:
```{r}
df <- data.frame(
  hhidpn = rep(1:3, each = 3),
  wave = rep(1:3, 3),
  treatment_time = rep(c(2,3,NA), each = 3),
  X1 = c(2,2,2,3,3,3,9,9,9),
  X2 = rep(c("a","a","b"), each = 3),
  X3 = c(9,4,5,6,7,2,3,4,8),
  X4 = c(8,9,4,5,6,7,2,3,4)
)

if (requireNamespace("survival", quietly = TRUE) &
    requireNamespace("nbpMatching", quietly = TRUE)) {
  example_pairs <- coxpsmatch(n_pairs = 1, data = df, id = "hhidpn", time = "wave", trt_time = "treatment_time")
}
```

First step of setting up data for matching:
8/6 - to do: update some of these to match "working with dates" instructions from https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#Part_1:_Introduction_to_Survival_Analysis
```{r}
matching_df_all_vars <- covid_admissions_bacterial %>% 
  group_by(mrn) %>% 
  mutate(first_inpatient_dt = min(adt_inpatient_dt),
         last_discharge_dt = max(adt_discharge_dt),
         covid_time_in_hospital = last_discharge_dt - first_inpatient_dt,
         covid_days_in_hospital = covid_time_in_hospital / ddays(1),
         first_bacterial_start_dt = min(first_dt, na.rm = T),
         age_at_admission = as.numeric((as_date(first_inpatient_dt) - as_date(dob))/365),
         bacterial_infection_ever = replace_na(bacterial_infection_ever, 0),
         bacterial_infection_ever = as.logical(bacterial_infection_ever),
         covid_and_bacterial_same_admission = replace_na(covid_and_bacterial_same_admission, F), 
         trt_time = case_when(!(first_bacterial_start_dt == Inf) ~ as.numeric(((first_bacterial_start_dt) - (first_inpatient_dt)) / ddays(1)))) %>% 
  group_by(mrn) %>% arrange(mrn, first_dt) %>% mutate(index = row_number()) %>% 
    # index sets it up for us to choose just one row per mrn (with info for the first infection)
    # This gets rid of duplicate rows per mrn because of duplicate admissions or duplicate bacterial infections
    # Somewhat similar to just using the summarize command, but I wanted to preserve some of the variables that are 
    # available on every row without having to include them explicitly in summarize, so I did it this way.
  filter(index == 1) 

```


I think matching function may not work because I don't have the data set up longitudinally. 
Amend the matching dataset some more to be in the appropriate format, even though the variables we 
are using right now are not time varying:
```{r}
matching_df <- matching_df_all_vars %>% 
  mutate(trt_time = trunc(trt_time)+1,
         covid_days_in_hospital = trunc(covid_days_in_hospital)+1) %>% 
    # for now, just truncating these - check later if appropriate
    # I did a weird thing and added one, to account for the fact the day 1 is in fact day 0, but will start counting from one. 
    # For example, if an HAI is acquired at 1.3, then it ocurred during the time span of 1-2 days, which we're calling day 2 
    # when using this uncount strategy vv
  filter(is.na(covid_days_in_hospital) == F) %>% 
    # toss anything that doesn't have a value for covid days in hospital
  mutate(count = covid_days_in_hospital) %>% 
    # make temporarily to use in uncount function
  uncount(count) %>% 
    # duplicates so we have one row per day in hospital
  group_by(mrn) %>% 
  mutate(time = row_number()) %>% 
  select(mrn, trt_time, time, covid_days_in_hospital, age_at_admission, sex, combined_race_ethnicity, insurance_type, adt_site, adt_care_level) %>% 
  mutate(age_at_admission = replace_na(age_at_admission, 200)) %>% 
  mutate_at(vars(sex:adt_care_level),  replace_na, "unknown")
    # ok I realize this is not great, but I'm going to plug in values for the few missing things here just to see if I can get the matching function to work. 
    # for now, include these variables only.
```


Run matching procedure:
```{r}
# pairs <- coxpsmatch(n_pairs = 227, data = matching_df, id = "mrn", time = "time", trt_time = "trt_time", 
#                    covariates = c("age_at_admission", "sex"))
#save pairs, because this took forever and ever to run, even though it obviously gave me the wrong results:
# write_csv(pairs, "./pairs_first_attempt.csv")

# , "combined_race_ethnicity", "insurance_type", "adt_site", "adt_care_level"))
```

```{r}
# pairs %>% filter(is.na(pair_id) == F)
# matching_df_all_vars %>% filter(is.na(trt_time) == F) %>% nrow()
```

Make datasets of treatment and control groups:
```{r}
treatment_mrns <- pairs %>% filter(type == "trt")
control_mrns <- pairs %>% filter(type == "all")
matched_mrns <- pairs %>% filter(is.na(type) == F)
matched_mrns %>% count(mrn) %>% nrow() # all matched mrns are unique

treatment_df <- treatment_mrns %>% left_join(matching_df_all_vars)
control_df <- control_mrns %>% left_join(matching_df_all_vars)
matched_df <- matched_mrns %>% left_join(matching_df_all_vars)
```

Make a few plots of preliminary results:
```{r}
matching_df_all_vars %>% 
  ggplot(aes(x = trt_time)) +
  geom_density() +
  labs(title = "Day of covid admission on which bacterial infection first detected", 
       x = "day", y = "density") +
  xlim(0, 210)

matched_df %>% 
  mutate(treat_control = case_when(type == "trt" ~ "infection", type == "all" ~ "no_infection")) %>% 
  ggplot(aes(x = covid_days_in_hospital, color = treat_control)) +
  geom_density() +
  labs(title = "Length of covid admissions after preliminary matching")

#t-test
ttest <- t.test(x = control_df$covid_days_in_hospital, y = treatment_df$covid_days_in_hospital)
ttest

control_df %>% 
  summarize(mean = mean(covid_days_in_hospital))
treatment_df %>% 
```

Troubleshoot:
```{r}
treatment_df %>% 
  select(mrn, type, covid_and_bacterial_same_admission, trt_time) %>% 
  view()

treatment_df %>% summarize(prop_w_infections = mean(covid_and_bacterial_same_admission))

control_df %>% summarize(prop_w_infections = mean(covid_and_bacterial_same_admission))

control_df %>% 
  select(mrn, type, covid_and_bacterial_same_admission, trt_time) %>% 
  view()
```
Ok, it seems like this didn't work at all - put people who were controls in the treatment group, people who were treated in the control group (we might expect a few of the latter, but not this many....). 

To do:
- handle how to deal with missing values
- add in additional variables including time varying ones
- check on how I did the rounding of days in hospital and treatment day and make sure it makes sense
- fix how "covid admissions" are defined - ie, if readmitted, make sure that gets included. 8/10 clarification: 
  check notes from Jason at meeting about encounter ID/ admission summary. Make sure to include everything relevant.
  I still haven't done this, just want to make sure I can set up the model correctly first. 

### Take two:

This time, I'll try running the coxph first, then looping (I think?) through the matching algorithm after that using... some other package.

Do coxph example from documentation:
```{r}
# Create the simplest test data set 
test1 <- list(time=c(4,3,1,1,2,2,3), 
              status=c(1,1,1,0,1,1,0), 
              x=c(0,2,1,1,1,0,0), 
              sex=c(0,0,0,0,1,1,1)) 
# Fit a stratified model 
example_model <- coxph(Surv(time, status) ~ x + strata(sex), test1) 
predict(example_model, type = "lp")
predict(example_model, type = "risk")
predict(example_model, type = "expected")
predict(example_model, type = "terms")

# Create a simple data set for a time-dependent model
#
test2 <- list(start=c(1, 2, 5, 2, 1, 7, 3, 4, 8, 8),
                stop =c(2, 3, 6, 7, 8, 9, 9, 9,14,17),
                event=c(1, 1, 1, 1, 1, 1, 1, 0, 0, 0),
                x    =c(1, 0, 0, 1, 0, 1, 1, 1, 0, 0) )


summary( coxph( Surv(start, stop, event) ~ x, test2))

example_model2 <- coxph( Surv(start, stop, event) ~ x, test2)

# Fit a stratified model, clustered on patients 

bladder1 <- bladder[bladder$enum < 5, ] 
coxph(Surv(stop, event) ~ (rx + size + number) * strata(enum),
      cluster = id, bladder1)

# Fit a time transform model using current age
coxph(Surv(time, status) ~ ph.ecog + tt(age), data=lung,
     tt=function(x,t,...) pspline(x + t/365.25))
```


Setup for coxph:
```{r}
cox_ph_df <- matching_df_all_vars %>% 
  mutate(time = case_when(is.na(trt_time) == F ~ trt_time, #time is time of bacterial infection (trt_time) if there was one
                          is.na(trt_time) == T ~ covid_days_in_hospital), # time is censoring time (days in hospital) if there wasn't an infection
         status = !is.na(trt_time)) %>% 
```

Run coxph:
```{r}
model <- coxph(Surv(time, status) ~ age_at_admission + sex, data = cox_ph_df)

coxph(Surv(time, status) ~ age_at_admission + sex, data = cox_ph_df) %>% 
  gtsummary::tbl_regression(exp = TRUE)
# Of course I should add quite a few other variables here - however, I think for the moment, I'll leave like this just to make sure I can set this up to run properly. 
```

Generate predictions from coxph model to use for matching:
```{r}
# Generate propensities
propensities <- predict(model, type = "risk") # not sure about type

# Add propensities (which are predicted risks..?) to cox_ph_df in order to use for risk set matching
rs_matching_df <- 
```






