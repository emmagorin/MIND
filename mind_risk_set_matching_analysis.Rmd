---
title: "risk set matching analysis "
output: 
  html_document:
  code_folding: hide
editor_options: 
  chunk_output_type: console
---

## Setup
Load packages
```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(knitr)
library(rsmatch)
library(survival)
library(nbpMatching)
library(MatchIt)
library(gtsummary)
```

Load files:
- covid_admissions_bact_blood: one line per covid inpatient stay, per blood bacterial infection during that stay
- covid_admissions_bact_urine: one line per covid inpatient stay, per urine bacterial infection during that stay
- covid_admissions_bact_resp: one line per covid inpatient stay, per respiratory bacterial infection during that stay
```{r}
setwd("/Users/emma/Desktop/local_only/mind_study")

# adt_long <- read_csv("./adt_long.csv")
adt_long_patients <- read_csv("./adt_long_patients.csv")
# covid_long <- read_csv("./covid_long.csv")
# micro_long <- read_csv("./micro_long.csv")
# micro_long_positives_only <- read_csv("./micro_long_positives_only.csv")
# patients <- read_csv("./patients.csv", col_types = cols(hospice_dt = col_datetime(format = "")))
bacterial_infections_blood <- read_csv("./bacterial_infections_blood.csv")
# bacterial_infections_urine <- read_csv("./bacterial_infections_urine.csv")
# bacterial_infections_resp <- read_csv("./bacterial_infections_resp.csv")
covid_admissions_bact_blood <- read_csv("./covid_admissions_bact_blood.csv")
covid_admissions_bact_urine <- read_csv("./covid_admissions_bact_urine.csv")
covid_admissions_bact_resp <- read_csv("./covid_admissions_bact_resp.csv")
```

Set options to vary analysis: uncomment section we want to run.
```{r}
## blood infections:
# df <- covid_admissions_bact_blood
# unmatchedplot <- "LOS unmatched - blood"
# plot1title <- "LOS after matching - blood"
# plot2title <- "LOS after matching, only uninfected controls - blood"
# tabletitle <- "Risk-set matching results - blood"

# urine infections:
df <- covid_admissions_bact_urine
unmatchedplot <- "LOS unmatched - urine"
plot1title <- "LOS after matching - urine"
plot2title <- "LOS after matching, only uninfected controls - urine"
tabletitle <- "Risk-set matching results - urine"
# 
# resp infections:
# df <- covid_admissions_bact_resp
# unmatchedplot <- "LOS unmatched - respiratory"
# plot1title <- "LOS after matching - respiratory"
# plot2title <- "LOS after matching, only uninfected controls - respiratory"
# tabletitle <- "Risk-set matching results - respiratory"
```

Options for individual pathogens:
```{r}
# Top 5 blood pathogens:
#path = "KLEBSIELLA PNEUMONIAE"
#path = "METHICILLIN-SUSCEPTIBLE STAPHYLOCOCCUS AUREUS"
#path = "ESCHERICHIA COLI"
#path = "PSEUDOMONAS AERUGINOSA"
#path = "ENTEROCOCCUS FAECALIS"

# top 5 urine pathogens:
 path = "ESCHERICHIA COLI"
# path = "CANDIDA ALBICANS"
# path = "KLEBSIELLA PNEUMONIAE"
# path = "CANDIDA GLABRATA"
# path = "ENTEROCOCCUS FAECALIS"

# top 5 respiratory pathogens:
# path = "PSEUDOMONAS AERUGINOSA"
# path = "KLEBSIELLA PNEUMONIAE"
# path = "METHICILLIN-SUSCEPTIBLE STAPHYLOCOCCUS AUREUS"
# path = "METHICILLIN-RESISTANT STAPHYLOCOCCUS AUREUS"
# path = "KLEBSIELLA (FORMERLY ENTEROBACTER) AEROGENES"
```


## Exploratory code also in mind_exploratory rmd file
Most of the following code is also in the mind_exploratory rmd file. Revisit questions about how many covid admissions each patient has and how many bacterial infections each patient has occuring during covid admissions:
```{r}
# # how many "covid admissions" does each patient have?
# adt_long_patients %>% 
#   group_by(mrn) %>% 
#   summarize(n_covid_admissions = sum(covid_admission)) %>% 
#   ungroup() %>% 
#   group_by(n_covid_admissions) %>% 
#   summarize(n = n()) %>% 
#   kable()
# 
# # How many infections did each covid patient have that occurred during covid inpatient admissions?
# covid_admissions_bacterial %>% 
#   group_by(mrn) %>% 
#   summarize(n_bacterial_infections = sum(bacterial_infection)) %>% 
#   ungroup() %>%  group_by(n_bacterial_infections) %>% 
#   summarize(n = n()) %>% 
#   kable()
#     # >1 means multiple infections 
# 
# # How many unique mrns are there?
# covid_admissions_bacterial %>%  count(mrn)
# 
# # examine details of covid admissions for patients with multiple covid admissions:
# adt_long_patients %>% 
#   group_by(mrn) %>% 
#   mutate(n_covid_admissions = sum(covid_admission)) %>% 
#   filter(n_covid_admissions > 1,
#          covid_admission == T) %>% 
#   select(mrn, encounter_id, adt_inpatient_dt, adt_discharge_dt, adt_site, adt_care_level, adt_discharge_disp) %>% 
#   view()
```
It seems that these multiple inpatients stays either have to do with transfer to a different care level (ICU, hospice, etc), 
or with multiple stays that are initiated by emergency room visits with the week following covid diagnosis.
I may want to look for transfers to ICU care that happen later in the trajectory for patients with covid admissions - 
ie, if they were admitted and then transferred and the transfer shows up as a different line.

## Plot length of stay pre-matching

```{r}
df %>% 
  group_by(mrn) %>% 
  summarize(first_inpatient_dt = min(adt_inpatient_dt),
            last_discharge_dt = max(adt_discharge_dt),
            bacterial_infection = as.logical(max(bacterial_infection))) %>% 
  mutate(covid_time_in_hospital = last_discharge_dt - first_inpatient_dt,
         covid_days_in_hospital = covid_time_in_hospital / ddays(1)) %>%
  ungroup() %>% 
  ggplot(aes(x = covid_days_in_hospital, color = bacterial_infection)) +
  geom_density() +
  scale_color_manual(values = alpha(c("red", "blue"))) +
  labs(title = unmatchedplot, 
       x = "Length of stay (days)")
```

ALTERNATE FOR SINGLE PATHOGEN ANALYSIS:
```{r}
df %>% 
  mutate(path_of_interest = case_when(organism_name == path ~ T,
                                      organism_name != path ~ F,
                                      is.na(organism_name) ~ F)) %>% 
  group_by(mrn) %>% 
  summarize(first_inpatient_dt = min(adt_inpatient_dt),
            last_discharge_dt = max(adt_discharge_dt),
            bacterial_infection = as.logical(max(bacterial_infection)),
            path_of_interest = as.logical(max(path_of_interest))) %>% 
  mutate(covid_time_in_hospital = last_discharge_dt - first_inpatient_dt,
         covid_days_in_hospital = covid_time_in_hospital / ddays(1)) %>%
  ungroup() %>% 
  ggplot(aes(x = covid_days_in_hospital, color = path_of_interest)) +
  geom_density() +
  scale_color_manual(values = alpha(c("red", "blue"))) +
  labs(title = paste(unmatchedplot, "-", path), 
       x = "Length of stay (days)")
```

## Set up data for matching
### Make df, one line per patient, all variables

Set up data for matching:
8/6 - to do: update some of these to match "working with dates" instructions from https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#Part_1:_Introduction_to_Survival_Analysis
```{r}
# set up first_bacterial_start_dt so that it reflects a single pathogen OR all pathogens based on the option of pathogen chosen.
if(pathogen == "all") {
  matching_df_all_vars <- df %>% 
    mutate(first_bacterial_start_dt = suppressWarnings(min(first_dt, na.rm = T)))
} else {
  matching_df_all_vars <- df %>% 
    mutate(path_of_interest_dt = ifelse(organism_name == pathogen, as_datetime(first_dt), NA),
          # path_of_interest_dt: date of detection of infection with the pathogen of interest, na if not pathogen of interest
           first_bacterial_start_dt = ifelse(!(all(is.na(path_of_interest_dt))), as_datetime(min(path_of_interest_dt, na.rm = T)), NA),
           first_bacterial_start_dt = as_datetime(first_path_of_interest_dt))
}

# all other options for the matching dataframe are the same regardless of pathogen choice
matching_df_all_vars <- matching_df_all_vars %>% 
  group_by(mrn) %>% 
  mutate(first_inpatient_dt = min(adt_inpatient_dt),
         last_discharge_dt = suppressWarnings(max(adt_discharge_dt, na.rm = T)),
         covid_time_in_hospital = last_discharge_dt - first_inpatient_dt,
         covid_days_in_hospital = covid_time_in_hospital / ddays(1),
         # first_bacterial_start_dt = suppressWarnings(min(first_dt, na.rm = T)),
         age_at_admission = as.numeric((as_date(first_inpatient_dt) - as_date(dob))/365),
         bacterial_infection_ever = replace_na(bacterial_infection_ever, 0),
         bacterial_infection_ever = as.logical(bacterial_infection_ever),
         covid_and_bacterial_same_admission = replace_na(covid_and_bacterial_same_admission, F),
         combined_race_ethnicity = factor(combined_race_ethnicity, 
                                          levels = c("White", "BLACK OR AFRICAN AMERICAN", "Hispanic/Latino", "other")),
         sex = factor(sex, levels = c("male", "female")),
         trt_time = case_when(!(first_bacterial_start_dt == Inf) ~ as.numeric(((first_bacterial_start_dt) - (first_inpatient_dt)) / ddays(1)))) %>% 
  group_by(mrn) %>% arrange(mrn, first_dt) %>% mutate(index = row_number()) %>% 
    # index sets it up for us to choose just one row per mrn (with info for the first infection)
    # This gets rid of duplicate rows per mrn because of duplicate admissions or duplicate bacterial infections
    # Somewhat similar to just using the summarize command, but I wanted to preserve some of the variables that are 
    # available on every row without having to include them explicitly in summarize, so I did it this way.
  filter(index == 1) %>% 
  filter(last_discharge_dt > first_inpatient_dt) %>% 
    # filter out anything where we have a missing last discharge date - at some point I can figure out what's up with this
  mutate(time = ifelse(is.na(trt_time) == T, covid_days_in_hospital, trt_time),
                          #time is time of bacterial infection (trt_time) if there was one
                          # time is censoring time (days in hospital) if there wasn't an infection
         time_dt = ifelse(first_bacterial_start_dt > ymd("2100-01-01"), last_discharge_dt, first_bacterial_start_dt),
         time_dt = as_datetime(time_dt),
                          #time is time of bacterial infection (trt_time) if there was one
                          # time is censoring time (days in hospital) if there wasn't an infection
                          # time_dt is version with absolute time instead of time since start of hospitalization
                          # Note: used this condition to replace "is.na" since that wasn't recognizing NAs for this variable for some reason.
         test = last_discharge_dt,
         status = !is.na(trt_time)) %>%
        # status is F if no infection (and therefore no "treatment time") and T if there was an infection
  filter(any(is.na(age_at_admission), is.na(sex), is.na(covid_visits_start_date), is.na(combined_race_ethnicity), is.na(bmi), is.na(dx_ckd), is.na(dx_dm), is.na(dx_htn), is.na(dx_cad), is.na(dx_hrt_failure), is.na(time), is.na(status)) == F)
  # filter out anything with a missing value for any of our predictor variables or status or time value
```
Note 8/11/22: We're missing a lot of BMIs - should I consider an alternative plan for this? Removing them all could create a bias

(8/23/22 - this has now been fixed above so no longer relevant) Check: does anyone have a missing first_inpatient_dt or last_discharge_dt? Is inpatient_dt < last_discharge_dt for anyone?
```{r}
matching_df_all_vars %>% filter(is.na(first_inpatient_dt) | is.na(last_discharge_dt))
matching_df_all_vars %>% filter(is.na(last_discharge_dt))
matching_df_all_vars %>% filter(first_inpatient_dt > last_discharge_dt) %>% view()
```
Ok, weirdly is.na(last_discharge_dt) is false, but there clearly are some where this is missing, based on the next check above. For now, let's just drop these - I'll do so in the time-invarying section

(8/23/22: this has now been fixed above, so no longer relevant) Check for missingness, since we will get rid of anything with missing variables:
```{r}
for (v in c("age_at_admission", "sex", "adt_status", "covid_visits_start_date", "combined_race_ethnicity", "insurance_type", "bmi", "dx_ckd", "dx_dm", "dx_htn",  "dx_cad",  "dx_hrt_failure")) {
  n_missing <- matching_df_all_vars %>% 
    filter(is.na(v)) %>% 
    summarize(n = n()) %>% 
    unlist()
  print(n_missing)
}

matching_df_all_vars %>% ungroup() %>% filter(is.na(age_at_admission)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(sex)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(adt_status)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(covid_visits_start_date)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(combined_race_ethnicity)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(insurance_type)) %>%  summarize(n = n()) #missing 333
matching_df_all_vars %>% ungroup() %>% filter(is.na(bmi)) %>%  summarize(n = n()) # - many bmi missing missing 589
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_ckd)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_dm)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_htn)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_cad)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_hrt_failure)) %>%  summarize(n = n())
```


#### Single pathogen version

ALTERNATE COXPH_DF: USE FOR INDIVIDUAL PATHOGEN ANALYSES.
COMMENT OUT SECTION ABOVE.
What's different about this version: variable "time" will be used to do the cox analysis, and refers to the time of infection of the pathogen of interest ONLY and otherwise is the time in hospital. variable "time_any_pathogen" is the time of infection for anyone who has had an infection at the site with any pathogen. It will be used for the sole purpose of determining the risk set from which to draw controls (ie, not including individuals who have already been infected with a different pathogen already as an eligible control.)

8/3/22 Note: Now that I'm returning to this project, I'm rethinking the above entirely. Why shouldn't people who have already had a different infection be controls? Perhaps I've addressed this differently in different places below, I'll check as I keep reviewing.



```{r}
# coxph_df <- matching_df_all_vars %>% 
#   mutate(time = case_when(is.na(trt_time) == F & organism_name == path ~ trt_time, 
#                           #time is time of bacterial infection of the pathogen of interest (trt_time) if there was one
#                           is.na(trt_time) == T ~ covid_days_in_hospital,
#                           organism_name != path ~ covid_days_in_hospital),
#                           # time is censoring time (days in hospital) if there wasn't an infection of the pathogen of interest.
#          time_any_pathogen = case_when(is.na(trt_time) == F ~ trt_time, 
#                           #time is time of bacterial infection (trt_time) if there was one
#                           is.na(trt_time) == T ~ covid_days_in_hospital),
#                           # time is censoring time (days in hospital) if there wasn't an infection
#          status = (organism_name == path)) %>% 
#         # status is F if no infection (and therefore no "treatment time") and T if there was an infection
#   filter(any(is.na(age_at_admission), is.na(sex), is.na(covid_visits_start_date), is.na(combined_race_ethnicity), is.na(bmi), is.na(dx_ckd), is.na(dx_dm), is.na(dx_htn), is.na(dx_cad), is.na(dx_hrt_failure), is.na(time), is.na(status)) == F) 
#   # filter out anything with a missing value for any of our predictor variables or status or time value
```


Checkpoint: did I correctly set status to be T for people who had infections, F otherwise?
```{r}
# coxph_df %>% 
#   ungroup() %>% 
#   summarize(prop_status_1 = mean(status),
#             n_with_status_1 = sum(status),
#             prop_covid_bacterial_same_admission = mean(covid_and_bacterial_same_admission),
#             n_covid_bacterial_same_admission = sum(covid_and_bacterial_same_admission))
```
9/10/21: These numbers should be the same, and yet they are slightly different! Need to look into why. Why do we have status = 1 for some people who are NOT listed as having covid and bacterial infections in the same admission? Look into how each variable was created to figure out. Not a big impediment, but need to figure out.
11/22/21: probably don't worry about this, now that I'm using this file for multiple types of infections and covid_bacterial_same_admission is only for bloodstream infections, I think.

Note 8/4/22: I believe the two sections below is focused on setting up with time-invarying covariates and then adding in previous infections as a time varying covariate. I had a lot of indecision about how to do this, and it seems complicated to set up. I will start with trying to figure out how to incorporate ICU stay as a time-varying covariate, and then return to the question of prior infections after that.

```{r}
# Step 1: set up dataframe with just MRN, time-invarying covariates, time of censoring or event, and event 1 or 0 (where event is onset of infection with path of interest)
# 
# path_of_interest <- df %>% 
#   group_by(mrn) %>% 
#   mutate(first_inpatient_dt = as_datetime(min(adt_inpatient_dt)), # beginning of hospital stay
#          last_discharge_dt = as_datetime(max(adt_discharge_dt)), # end of hospital stay
#          age_at_admission = as.numeric((as_date(first_inpatient_dt) - as_date(dob))/365.25),
#          combined_race_ethnicity = factor(combined_race_ethnicity, 
#                                           levels = c("White", "BLACK OR AFRICAN AMERICAN", "Hispanic/Latino", "other")),
#          sex = factor(sex, levels = c("male", "female")),
#          #test = first_dt, 2/24 - not sure we need this line, think this was actually a test.
#          path_of_interest_dt = ifelse(organism_name == path, as_datetime(first_dt), NA),
#              # path_of_interest_dt: date of detection of infection with the pathogen of interest, na if not pathogen of interest
#          first_path_of_interest_dt = ifelse(!(all(is.na(path_of_interest_dt))), as_datetime(min(path_of_interest_dt, na.rm = T)), NA),
#          first_path_of_interest_dt = as_datetime(first_path_of_interest_dt),
#              # first_path_of_interest_dt: date of first detection of path of interest if patient ever had pathogen of interest
#          time = ifelse(is.na(first_path_of_interest_dt),
#                        as.numeric(((last_discharge_dt) - (first_inpatient_dt)) / ddays(1)),
#                        as.numeric(((first_path_of_interest_dt) - (first_inpatient_dt)) / ddays(1))),
#              # time: time until event if patient had one (detection of pathogen of interest) OR censoring (discharge from hospital)
#          event = !is.na(path_of_interest_dt)) %>%
#   arrange(mrn, first_dt) %>% mutate(index = row_number()) %>% filter(index == 1) %>% 
#     # index sets it up for us to choose just one row per mrn, which should include all information we need.
#     # This gets rid of duplicate rows per mrn because of duplicate admissions or duplicate bacterial infections
#     # Somewhat similar to just using the summarize command, but I wanted to preserve some of the variables that are 
#     # available on every row without having to include them explicitly in summarize, so I did it this way.
#   select(mrn, first_inpatient_dt, last_discharge_dt, age_at_admission, combined_race_ethnicity, sex, first_path_of_interest_dt, time, event)
#  
# 1/25/22: Will want to add in other baseline variables at some point.
```



### Set up time-varying covariates
#### Prior Infections:
```{r}
# Step 2: set up dataframe with one row per MRN, time = 0 and other infection = 0
step_2 <- df %>% 
  group_by(mrn) %>% 
  mutate(index = row_number()) %>% filter(index == 1) %>% 
  select(mrn) %>% # This is just a list of mrns at this point!
  mutate(time = 0,
         other_infection = 0)

# is this step necessary? not sure...


# Step 3: set up dataframe with just MRN, time of onset of other infection (that's not path of interest) and other_infection = 1 (since we're only keeping lines that do have another infection with a different pathogen) - or variation that Jeff suggested, with categories 1-5 for five days after other infection was detected.

# step 3a: set up variables with times of other infections through 1 day after last positive test.
step_3a <- df %>% 
  #group_by(mrn) %>% 
  mutate(start = ifelse((organism_name!=path & !is.na(organism_name)), as_datetime(first_dt), NA),
         start = as_datetime(start),
             # start: date and time of onset of a different bacterial infection at the same site
         stop = ifelse((organism_name!=path & !is.na(organism_name)), as_datetime(last_dt), NA),
         stop = as_datetime(stop),
         stop = as_datetime(stop + as.duration("24 hours"))
         ) %>% 
  select(mrn, start, stop, first_dt, last_dt, organism_name) %>% 
  filter(!is.na(start)) %>% 
  arrange(mrn) %>% 
  mutate(other_infection_lag0 = T)

# steps 3b - 3e: set up one day after day of infection lags as their own variables, with appropriate start and stop times. 
step_3b <- step_3a %>% 
  mutate(start = stop,
            # start time for second lag = stop time for first lag
         stop = as_datetime(start + as.duration("24 hours")),
         other_infection_lag1 = T
         )

step_3c <- step_3b %>% 
  mutate(start = stop,
            # start time for second lag = stop time for first lag
         stop = as_datetime(start + as.duration("24 hours")),
         other_infection_lag2 = T
         )

step_3d <- step_3c %>% 
  mutate(start = stop,
            # start time for second lag = stop time for first lag
         stop = as_datetime(start + as.duration("24 hours")),
         other_infection_lag3 = T
         )

step_3e <- step_3d %>% 
  mutate(start = stop,
            # start time for second lag = stop time for first lag
         stop = as_datetime(start + as.duration("24 hours")),
         other_infection_lag4 = T
         )


# Question here: do we need to worry about multiple overlapping infections "resetting the clock" kind of? ie, if someone gets infection a on day 0 and then infection b on day .5, will we be accidentally creating a "one day out" line on day 1, when it shouldn't be until day 1.5..?
# check this by checking how many people really have multiple infections. 
step_3 %>% 
  filter(!(is.na(other_infection_dt))) %>% 
  group_by(mrn) %>% 
  summarize(n_infections = n()) %>% 
  group_by(n_infections) %>% 
  summarize(n_infections = sum(n_infections))
# Yes, there are numerous people with multiple "other infections"

# how to handle: see above. I set up separate variables, so it's possible to be on "infection lag 0" and simultaneously on "infection lag 2" for instance. they're no longer mutually exclusive. 



# Step 4: combine 2 and 3

# step 5: make a similar thing but with ICU stays

# step 6: use tmerge on 1,4 and 5 to set up data for coxph. 
  

# step 7???? might need to set up the rest of the matching df (like, time in hospital, etc) to use for the matching step later. 
```

#### ICU Stays

Some exploration:
```{r}
temp <- adt_long_patients %>% 
  filter(adt_status != adt_care_level)
# only 20 instances in which adt_status !=adt_care_level, all of which have adt_status = outpatient and adt_care_level = acute. Not sure why this is the case, mostly in "infusion" cases

# Let's look at ppl who have been in the ICU to get a sense of how the dataset is structured:
temp <- adt_long_patients %>% 
  filter(adt_status == "Intensive Care (ICU)")

# make list of mrns who have ever been in the ICU
icu_mrns <- adt_long_patients %>% 
  filter(adt_status == "Intensive Care (ICU)")  %>% 
  select(mrn) 

# Look at all adt records of anyone who has been in the ICU:
adt_long_patients %>% 
  filter(mrn %in% icu_mrns$mrn) %>% 
  view()

# do any of them have "inpatient" as their care status?
adt_long_patients %>% 
  filter(mrn %in% icu_mrns$mrn, 
         adt_status == "Inpatient") %>% 
  view()

# Look at some examples who have a bunch of ICU stays:
adt_long_patients %>% filter(mrn == 1000583708) %>% view()
adt_long_patients %>% filter(mrn == 1000375054) %>% view()
adt_long_patients %>% filter(mrn == 1004941330) %>% view()
adt_long_patients %>% filter(mrn == 1004752835) %>% view()
adt_long_patients %>% filter(mrn == 1200173905) %>% view()

# let's see how the "covid admissions "covid admissions" correspond for some of these patients.
# Who is there who even was in the ICU who also had a covid infection? - plenty of ppl, it seems
covid_admissions_bact_blood %>% filter(mrn %in% icu_mrns$mrn) %>% view()
covid_admissions_bact_resp %>% filter(mrn %in% icu_mrns$mrn) %>% view()
covid_admissions_bact_urine %>% filter(mrn %in% icu_mrns$mrn) %>% view()
	

# This one is making me confused about the covid visit start - it looks like one of these first had a pos covid test at discharge? Look into how that variable was defined.
```

Make extremely simple ICU variable that can be tmerged (I think) in with the basic data
```{r}
icu_mrns <- adt_long_patients %>% 
  filter(adt_status == "Intensive Care (ICU)")  %>% 
  select(mrn) 

icu_stay <- df %>% 
  group_by(mrn) %>% 
  mutate(first_inpatient_dt = min(adt_inpatient_dt),
         icu = (adt_care_level == "Intensive Care (ICU)"),
         icu_start = (adt_inpatient_dt - first_inpatient_dt)/ddays(1),
         icu_stop = (adt_discharge_dt - first_inpatient_dt)/ddays(1)) %>% 
  select(mrn, adt_care_level, icu, icu_start, adt_event_dt, icu_stop, adt_discharge_dt)

# checkpoint: how does this look for ppl with ICU stays only?
# icu_stay %>% filter(mrn %in% icu_mrns$mrn) %>% arrange(mrn) %>% view()
```
Note 8/5: mostly looks good, there appear to be a few duplicated lines, which is confusing, but otherwise seems ok.

Note 8/15/22: reformatting this to be time since original admission, in hopes that that will make this more compatible with tmerge step below. Need to update so I don't end up with slightly negative time values - I think this is because of discrepancy btw adt event time and adt admission time - make this more consistent throughout.


### Add time-varying covariates

#### All pathogens version
First pass, set up for the the "any infection" version
Add ICU variable - try to use tmerge

```{r}
# set up dataframe
coxph_df <- tmerge(data1 = matching_df_all_vars, data2 = matching_df_all_vars, id = mrn, infection = event(time = time, status))

# Add ICU variable
coxph_df <- tmerge(coxph_df, icu_stay, id = mrn, icu = tdc(icu_start, icu))

# # Checkpoint: did ICU merge work? view with fewer variables overall:
# coxph_df2 %>% 
#   select(mrn, time, tstart, tstop, status, infection, icu) %>% 
#   filter(mrn %in% icu_mrns$mrn) %>% arrange(mrn) %>% view()
# # success, I think! at least, patients with icu stays seem to successfully have starts and stops to them....
# could I have done this much faster manually? Yes, probably. But worth learning maybe?
```

note 8/15: I think this works, but need to check to make sure I didn't create a problem by using the first adt_inpatient as the baseline for the infections, and the adt_event as the baseline for the icu variable. 
Nevermind - I think this is fine!

Checkpoint: Observe if the "infection" variable did what I expected it to do after the merge.
```{r}
# make temp dataset with just those with infections and select variables to try to see if we can 
temp <- coxph_df %>% 
  select(mrn, status, infection, time, tstart, tstop, icu) %>% 
  filter(mrn %in% icu_mrns$mrn) %>% 
  arrange(mrn)
```
I think this works - what I looked for in scrolling through is that in cases where the person has multiple observations, only the final one should have infetion = T if any. 



## Run coxph model to create propensity scores


### Set up cox model:
```{r}
coxph_model <- coxph(Surv(tstart, tstop, infection) ~ age_at_admission + sex + covid_visits_start_date + combined_race_ethnicity + bmi + dx_dm + dx_htn + dx_cad + dx_hrt_failure + icu, data = coxph_df)

coxph_model %>% 
  gtsummary::tbl_regression(exp = TRUE, estimate_fun = function(x) style_ratio(x, digits = 4))
# Of course I should add quite a few other variables here - however, I think for the moment, I'll leave like this just to make sure I can set this up to run properly. 
```


9/1/21: notes on things still to do:
- adapt variables to have appropriate reference groups.
- why doesn't propensity come out as as long as the coxph_model dataframe? Are there a bunch missing all their variables or soemthing????
    Update 9/2: had to do with missing values. updating to napredict might work.....


## Set up results DF
Set up dataframe to record results:
```{r}
ttest_output <- tibble(sample = c("unmatched", "matched", "matched - uninfected controls only"), 
                       estimate = c(0, 0, 0),
                       CI_lb = c(0, 0, 0),
                       CI_ub = c(0,0,0))
```


## Matching and results considering not-yet infected people as controls:

### Matching:

Make matches dataframe. This will serve both as a list of infection times from which to we'll draw infections, and as a place to put the matches output.
```{r}
matches <- matching_df_all_vars %>% 
  select(mrn, trt_time) %>% 
  filter(is.na(trt_time) == F) %>% 
  arrange(trt_time) %>% 
  mutate(ctrl_mrn = NA)
```

Run the matching process, revised to be with replacement and to work with time-varying covariates.
Outputs a list of infection mrns and their matches.
```{r}
for(i in 1:nrow(matches)) {
  # set infection time:
  infection_time <- matches$trt_time[i]
  
  # set infected person's data:
  infected_person <- coxph_df %>% 
    filter(mrn == matches$mrn[i], tstop == infection_time)
  
  # calculate infected person's propensity:
  infected_propensity <- predict(coxph_model, newdata = infected_person)

  # create riskset based on infection time: riskset is people who are still at risk (in hospital) and not yet infected 
  # pick appropriate line for time-varying covariates by picking lines where infection_time falls btw tstart and tstop
  riskset <- coxph_df %>% 
    filter(tstart < infection_time, infection_time < tstop) 
 
  # calculate propensity:
  riskset$propensity_score <-  predict(coxph_model, newdata = riskset, id = mrn)
  
  # pick control among eligible riskset based on propensity:
  control <- riskset %>% 
    filter(is.na(propensity_score) == F) %>% 
    mutate(propensity_difference = abs(propensity_score - infected_propensity),
           min_propensity_difference = min(propensity_difference)) %>% 
    filter(propensity_difference == min_propensity_difference) # select person with closest propensity

  # plug info about control into matches df
  matches$ctrl_mrn[i] <- control$mrn[1]
}
```
ok, well, this does something...




SINGLE PATHOGEN VARIATION: time_any_path must be greater than the next exposed person's time_any_path - ie, this is where we exclude people already infected with a different pathogen from the potential control group.

8/3/22 note: I've set this up without replacement, but I'm thinking it will be both easier and more correct to set it up WITH replacement based on my reading yesterday. Maybe redo to change this.

```{r}
# for(i in 1:nrow(matches)) {
#   # pick control among eligible riskset based on propensity
#   temp <- riskset %>% 
#     filter(time_any_pathogen >= matches$time_any_pathogen[i], # riskset only includes those still at risk
#            mrn != matches$mrn[i]) %>% # and not infection we're trying to match
#     mutate(propensity_difference = abs(propensity - matches$propensity[i])) %>% 
#     filter(propensity_difference == min(propensity_difference))
#       # keep control with closest risk to the infection we're matching
#   
#   # plug info about control into matches df
#   matches$ctrl_mrn[i] <- temp$mrn[1]
#   matches$ctrl_propensity[i] <- temp$propensity[1]
#   matches$ctrl_time[i] <- temp$time[1]
#   matches$ctrl_status[i] <- temp$status[1]
#   matches$ctrl_covid_days_in_hospital[i] <- temp$covid_days_in_hospital[1]
#   
#   # save new riskset excluding the control that was just matched 
#   riskset <- riskset %>% filter(mrn!=temp$mrn[1])
# }
```

For now, we've included infected people as potential controls if they're still in the risk set, but this could be easily changed. 
Assess how often people with infections got selected as controls:
```{r}
coxph_df %>% 
  filter(mrn %in% matches$ctrl_mrn) %>% 
  mutate(infected = is.na(trt_time)) %>% 
  ungroup() %>% 
  summarize(n_infected_controls = sum(infected),
            prop_infected_controls = mean(infected))

```
 This is higher than would be seen at random, but is consistent with literature (at least in that "later exposed" ppl are selected as controls more often than random), because presumably these individuals have commonalities with the infected individuals they serve as controls for.

8/22/22 - damn, that's a lot. Will need to think about how we did this, and if this is reasonable.....

### Set up datasets:

Set up dataset with all data and the matched individuals only
```{r}
# make a list of ids of the people who were matched
matched_ppl <- c(unlist(matches$mrn), unlist(matches$ctrl_mrn))

# make dataset of matching ppl only
matched_ppl_df <- coxph_df %>% filter(mrn %in% matched_ppl)
```

### Check covariate balance:
```{r}
# # compare baseline characteristics in the unmatched sample:
# example_df %>% 
#   group_by(status) %>% 
#   summarize(mean_cov1 = mean(cov1),
#             sd_cov1 = sd(cov1),
#             mean_cov2 = mean(cov2),
#             sd_cov2 = sd(cov2),
#             mean_cov3 = mean(cov3),
#             sd_cov3 = sd(cov3))
# 
# # compare baseline characteristics in the matched sample:
# matched_ppl_df %>% 
#   group_by(status) %>% 
#   summarize(mean_cov1 = mean(cov1),
#             sd_cov1 = sd(cov1),
#             mean_cov2 = mean(cov2),
#             sd_cov2 = sd(cov2),
#             mean_cov3 = mean(cov3),
#             sd_cov3 = sd(cov3))
# 
# # following Hade et al, look at covariate impact on treatment hazard before and after matching:
# # before matching:
# coxph_model
# 
# #after matching:
# coxph_model_matched <- coxph(Surv(time, status) ~ cov1 + cov2 + cov3, data = matched_ppl_df)
# coxph_model_matched
```

Notes: more resources on checking balance:
https://cran.r-project.org/web/packages/MatchIt/vignettes/assessing-balance.html
https://onlinelibrary-wiley-com.ezproxy.cul.columbia.edu/doi/epdf/10.1002/sim.3697

In this very small example, there was already a pretty good balance between groups in the 
covariates before matching, and comparable balance after matching. I don't expect this to be the 
case with the real data.

### Look at results:

```{r}
# make subsets of data to use for t-tests (there's surely a quicker way, but this should work)
infected <- matches %>% select(mrn:covid_days_in_hospital)
all_uninfected <- coxph_df %>% filter(status == F)
controls <- matches %>% select(ctrl_mrn:ctrl_covid_days_in_hospital)
  

# unmatched sample:
unmatched_ttest <-t.test(x = infected$covid_days_in_hospital, y = all_uninfected$covid_days_in_hospital) 

# matched sample:
#t.test(x = infected$covid_days_in_hospital, y = controls$ctrl_covid_days_in_hospital)

# matched paired sample t-test (following watson et al for this)
matched_ttest <- matches %>% mutate(diff = covid_days_in_hospital - ctrl_covid_days_in_hospital) %>% 
  pull(diff) %>% 
  t.test()

# put ttest results in table
ttest_output[1,2] <- unmatched_ttest$estimate["mean of x"] - unmatched_ttest$estimate["mean of y"]
ttest_output[1,3] <- unmatched_ttest$conf.int[1]
ttest_output[1,4] <- unmatched_ttest$conf.int[2]
ttest_output[2,2] <- matched_ttest$estimate
ttest_output[2,3] <- matched_ttest$conf.int[1]
ttest_output[2,4] <- matched_ttest$conf.int[2]
```

Plot results:
```{r}
matches %>% 
  ggplot(aes(x = covid_days_in_hospital)) +
  geom_density(color = "blue") +
  geom_density(aes(x = ctrl_covid_days_in_hospital), color = "red") +
  labs(title = paste(plot1title, "-", path), 
       x = "Length of stay (days)")
```

## Matching and procedure and results considering only never-infected people as controls:
note 8/3: This doesn't really make sense, I think I should probably should consider anyone not-yet-infected to be a control.

### Matching:

Set up "risk set" dataframe, which will include ONLY UNINFECTED people
```{r}
riskset2 <- tibble(coxph_df, propensity) %>% 
  select(mrn, status, propensity, time, covid_days_in_hospital) %>% 
  filter(status == F)

infected2 <- tibble(coxph_df, propensity) %>% 
  select(mrn, status, propensity, time, covid_days_in_hospital) %>% 
  filter(status == T)
```

Set up dataframe of infection times with space for output:
```{r}
matches2 <- infected2 %>% 
  select(mrn, propensity, time, status, covid_days_in_hospital) %>% 
  arrange(time) %>% 
  mutate(ctrl_mrn = NA, ctrl_propensity = NA, ctrl_time = NA, ctrl_status = NA, ctrl_covid_days_in_hospital = NA)
```

Now run the matching process:
```{r}
for(i in 1:nrow(matches2)) {
  # pick control among eligible riskset based on propensity
  temp <- riskset2 %>% 
    filter(time >= matches2$time[i], # riskset only includes those still at risk
           mrn != matches2$mrn[i]) %>% # and not infection we're trying to match
    mutate(propensity_difference = abs(propensity - matches2$propensity[i])) %>% 
    filter(propensity_difference == min(propensity_difference))
      # keep control with closest risk to the infection we're matching
  
  # plug info about control into matches df
  matches2$ctrl_mrn[i] <- temp$mrn[1]
  matches2$ctrl_propensity[i] <- temp$propensity[1]
  matches2$ctrl_time[i] <- temp$time[1]
  matches2$ctrl_status[i] <- temp$status[1]
  matches2$ctrl_covid_days_in_hospital[i] <- temp$covid_days_in_hospital[1]
  
  # save new riskset excluding the control that was just matched 
  riskset2 <- riskset2 %>% filter(mrn!=temp$mrn[1])
}
```

### Results:

```{r}
# make subsets of data to use for t-tests (there's surely a quicker way, but this should work)
# infected <- matches %>% select(mrn:covid_days_in_hospital)
# all_uninfected <- coxph_df %>% filter(status == F)
controls2 <- matches2 %>% select(ctrl_mrn:ctrl_covid_days_in_hospital) 

# unmatched sample:
t.test(x = infected$covid_days_in_hospital, y = all_uninfected$covid_days_in_hospital)

# matched sample:
#t.test(x = infected$covid_days_in_hospital, y = controls2$ctrl_covid_days_in_hospital)

# paired sample t-test (following watson et al for this)
matched_ttest2 <- matches2 %>% mutate(diff = covid_days_in_hospital - ctrl_covid_days_in_hospital) %>% 
  pull(diff) %>% # pick 
  t.test()

# put ttest results in df
ttest_output[3,2] <- matched_ttest2$estimate
ttest_output[3,3] <- matched_ttest2$conf.int[1]
ttest_output[3,4] <- matched_ttest2$conf.int[2]
```

Plot results:
```{r}
matches2 %>% 
  ggplot(aes(x = covid_days_in_hospital)) +
  geom_density(color = "blue") +
  geom_density(aes(x = ctrl_covid_days_in_hospital), color = "red") +
  labs(title = plot2title, 
       x = "Length of stay (days)")
```

View results of all tests:
```{r echo=FALSE}
ttest_output %>% 
  kable() #caption = paste(tabletitle, "-", path))
```



























