---
title: "risk set matching analysis "
output: 
  html_document:
  code_folding: hide
editor_options: 
  chunk_output_type: console
---

# Setup, load packages
```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(knitr)
library(rsmatch)
library(survival)
library(nbpMatching)
library(MatchIt)
```

```{r}
setwd("/Users/emma/Desktop/local_only/mind_study")

adt_long <- read_csv("./adt_long.csv")
adt_long_patients <- read_csv("./adt_long_patients.csv")
covid_long <- read_csv("./covid_long.csv")
micro_long <- read_csv("./micro_long.csv")
micro_long_positives_only <- read_csv("./micro_long_positives_only.csv")
patients <- read_csv("./patients.csv", col_types = cols(hospice_dt = col_datetime(format = "")))
bacterial_infections <- read_csv("./bacterial_infections.csv")
covid_admissions_bacterial <- read_csv("./covid_admissions_bacterial.csv")
```

# Exploratory code also in mind_exploratory rmd file
Most of the following code is also in the mind_exploratory rmd file. Revisit questions about how many covid admissions each patient has and how many bacterial infections each patient has occuring during covid admissions:
```{r}
# how many "covid admissions" does each patient have?
adt_long_patients %>% 
  group_by(mrn) %>% 
  summarize(n_covid_admissions = sum(covid_admission)) %>% 
  ungroup() %>% 
  group_by(n_covid_admissions) %>% 
  summarize(n = n()) %>% 
  kable()

# How many infections did each covid patient have that occurred during covid inpatient admissions?
covid_admissions_bacterial %>% 
  group_by(mrn) %>% 
  summarize(n_bacterial_infections = sum(bacterial_infection)) %>% 
  ungroup() %>%  group_by(n_bacterial_infections) %>% 
  summarize(n = n()) %>% 
  kable()
    # >1 means multiple infections 

# How many unique mrns are there?
covid_admissions_bacterial %>%  count(mrn)

# examine details of covid admissions for patients with multiple covid admissions:
adt_long_patients %>% 
  group_by(mrn) %>% 
  mutate(n_covid_admissions = sum(covid_admission)) %>% 
  filter(n_covid_admissions > 1,
         covid_admission == T) %>% 
  select(mrn, encounter_id, adt_inpatient_dt, adt_discharge_dt, adt_site, adt_care_level, adt_discharge_disp) %>% 
  view()
```
It seems that these multiple inpatients stays either have to do with transfer to a different care level (ICU, hospice, etc), 
or with multiple stays that are initiated by emergency room visits with the week following covid diagnosis.
I may want to look for transfers to ICU care that happen later in the trajectory for patients with covid admissions - 
ie, if they were admitted and then transferred and the transfer shows up as a different line.

See mind exploratory for this part:
What happens if we consider re-admissions that aren't within the timeframe (48 hrs before covid diagnosis through 7 days after) that would label them a "covid admission", but do occur shortly after a covid discharge, suggesting that they're likely still related to the same health concerns? eg, what if we consider admissions within 48 hrs of previous admission to be part of the same thing?



# Initial step to set up data for matching:

First step of setting up data for matching:
8/6 - to do: update some of these to match "working with dates" instructions from https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html#Part_1:_Introduction_to_Survival_Analysis
```{r}
matching_df_all_vars <- covid_admissions_bacterial %>% 
  group_by(mrn) %>% 
  mutate(first_inpatient_dt = min(adt_inpatient_dt),
         last_discharge_dt = max(adt_discharge_dt),
         covid_time_in_hospital = last_discharge_dt - first_inpatient_dt,
         covid_days_in_hospital = covid_time_in_hospital / ddays(1),
         first_bacterial_start_dt = min(first_dt, na.rm = T),
         age_at_admission = as.numeric((as_date(first_inpatient_dt) - as_date(dob))/365),
         bacterial_infection_ever = replace_na(bacterial_infection_ever, 0),
         bacterial_infection_ever = as.logical(bacterial_infection_ever),
         covid_and_bacterial_same_admission = replace_na(covid_and_bacterial_same_admission, F),
         combined_race_ethnicity = factor(combined_race_ethnicity, 
                                          levels = c("White", "BLACK OR AFRICAN AMERICAN", "Hispanic/Latino", "other")),
         sex = factor(sex, levels = c("male", "female")),
         trt_time = case_when(!(first_bacterial_start_dt == Inf) ~ as.numeric(((first_bacterial_start_dt) - (first_inpatient_dt)) / ddays(1)))) %>% 
  group_by(mrn) %>% arrange(mrn, first_dt) %>% mutate(index = row_number()) %>% 
    # index sets it up for us to choose just one row per mrn (with info for the first infection)
    # This gets rid of uplicate rows per mrn because of duplicate admissions or duplicate bacterial infections
    # Somewhat similar to just using the summarize command, but I wanted to preserve some of the variables that are 
    # available on every row without having to include them explicitly in summarize, so I did it this way.
  filter(index == 1)


# set up plot
# matching_df_all_vars %>% 
#   geom_line(aes(x = covid_days_in_hospital, color = status) 
```

# First attempt at matching - with rsmatch package.

Try the example given with the rsmatch package:
```{r}
df <- data.frame(
  hhidpn = rep(1:3, each = 3),
  wave = rep(1:3, 3),
  treatment_time = rep(c(2,3,NA), each = 3),
  X1 = c(2,2,2,3,3,3,9,9,9),
  X2 = rep(c("a","a","b"), each = 3),
  X3 = c(9,4,5,6,7,2,3,4,8),
  X4 = c(8,9,4,5,6,7,2,3,4)
)

if (requireNamespace("survival", quietly = TRUE) &
    requireNamespace("nbpMatching", quietly = TRUE)) {
  example_pairs <- coxpsmatch(n_pairs = 1, data = df, id = "hhidpn", time = "wave", trt_time = "treatment_time")
}
```


I think matching function may not work because I don't have the data set up longitudinally. 
Amend the matching dataset some more to be in the appropriate format, even though the variables we 
are using right now are not time varying:
```{r}
matching_df <- matching_df_all_vars %>% 
  mutate(trt_time = trunc(trt_time)+1,
         covid_days_in_hospital = trunc(covid_days_in_hospital)+1) %>% 
    # for now, just truncating these - check later if appropriate
    # I did a weird thing and added one, to account for the fact the day 1 is in fact day 0, but will start counting from one. 
    # For example, if an HAI is acquired at 1.3, then it ocurred during the time span of 1-2 days, which we're calling day 2 
    # when using this uncount strategy vv
  filter(is.na(covid_days_in_hospital) == F) %>% 
    # toss anything that doesn't have a value for covid days in hospital
  mutate(count = covid_days_in_hospital) %>% 
    # make temporarily to use in uncount function
  uncount(count) %>% 
    # duplicates so we have one row per day in hospital
  group_by(mrn) %>% 
  mutate(time = row_number()) %>% 
  select(mrn, trt_time, time, covid_days_in_hospital, age_at_admission, sex, combined_race_ethnicity, insurance_type, adt_site, adt_care_level) %>% 
  mutate(age_at_admission = replace_na(age_at_admission, 200)) %>% 
  mutate_at(vars(sex:adt_care_level),  replace_na, "unknown")
    # ok I realize this is not great, but I'm going to plug in values for the few missing things here just to see if I can get the matching function to work. 
    # for now, include these variables only.
```


Run matching procedure:
```{r}
# pairs <- coxpsmatch(n_pairs = 227, data = matching_df, id = "mrn", time = "time", trt_time = "trt_time", 
#                    covariates = c("age_at_admission", "sex"))
#save pairs, because this took forever and ever to run, even though it obviously gave me the wrong results:
# write_csv(pairs, "./pairs_first_attempt.csv")

# , "combined_race_ethnicity", "insurance_type", "adt_site", "adt_care_level"))
```

```{r}
# pairs %>% filter(is.na(pair_id) == F)
# matching_df_all_vars %>% filter(is.na(trt_time) == F) %>% nrow()
```

Make datasets of treatment and control groups:
```{r}
treatment_mrns <- pairs %>% filter(type == "trt")
control_mrns <- pairs %>% filter(type == "all")
matched_mrns <- pairs %>% filter(is.na(type) == F)
matched_mrns %>% count(mrn) %>% nrow() # all matched mrns are unique

treatment_df <- treatment_mrns %>% left_join(matching_df_all_vars)
control_df <- control_mrns %>% left_join(matching_df_all_vars)
matched_df <- matched_mrns %>% left_join(matching_df_all_vars)
```

Make a few plots of preliminary results:
```{r}
matching_df_all_vars %>% 
  ggplot(aes(x = trt_time)) +
  geom_density() +
  labs(title = "Day of covid admission on which bacterial infection first detected", 
       x = "day", y = "density") +
  xlim(0, 210) 


matched_df %>% 
  mutate(treat_control = case_when(type == "trt" ~ "infection", type == "all" ~ "no_infection")) %>% 
  ggplot(aes(x = covid_days_in_hospital, color = treat_control)) +
  geom_density() +
  labs(title = "Length of covid admissions after preliminary matching",
       x = "Length of stay (days)")

#t-test
ttest <- t.test(x = control_df$covid_days_in_hospital, y = treatment_df$covid_days_in_hospital)
ttest

control_df %>% 
  summarize(mean = mean(covid_days_in_hospital))
treatment_df %>% 
```

Troubleshoot:
```{r}
treatment_df %>% 
  select(mrn, type, covid_and_bacterial_same_admission, trt_time) %>% 
  view()

treatment_df %>% summarize(prop_w_infections = mean(covid_and_bacterial_same_admission))

control_df %>% summarize(prop_w_infections = mean(covid_and_bacterial_same_admission))

control_df %>% 
  select(mrn, type, covid_and_bacterial_same_admission, trt_time) %>% 
  view()
```
Ok, it seems like this didn't work at all - put people who were controls in the treatment group, people who were treated in the control group (we might expect a few of the latter, but not this many....). 

To do:
- handle how to deal with missing values
- add in additional variables including time varying ones
- check on how I did the rounding of days in hospital and treatment day and make sure it makes sense
- fix how "covid admissions" are defined - ie, if readmitted, make sure that gets included. 8/10 clarification: 
  check notes from Jason at meeting about encounter ID/ admission summary. Make sure to include everything relevant.
  I still haven't done this, just want to make sure I can set up the model correctly first. 


# Second attempt at matching:

This time, I'll try running the coxph first, then loop through a simple matching algorithm

## Setup for coxph. 

Check for missingness, since we will get rid of anything with missing variables:
```{r}

for (v in c("age_at_admission", "sex", "adt_status", "covid_visits_start_date", "combined_race_ethnicity", "insurance_type", "bmi", "dx_ckd", "dx_dm", "dx_htn",  "dx_cad",  "dx_hrt_failure")) {
  n_missing <- matching_df_all_vars %>% 
    filter(is.na(v)) %>% 
    summarize(n = n()) %>% 
    unlist()
  print(n_missing)
}
matching_df_all_vars %>% ungroup() %>% filter(is.na(age_at_admission)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(sex)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(adt_status)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(covid_visits_start_date)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(combined_race_ethnicity)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(insurance_type)) %>%  summarize(n = n()) #missing 333
matching_df_all_vars %>% ungroup() %>% filter(is.na(bmi)) %>%  summarize(n = n()) # - many bmi missing missing 589
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_ckd)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_dm)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_htn)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_cad)) %>%  summarize(n = n())
matching_df_all_vars %>% ungroup() %>% filter(is.na(dx_hrt_failure)) %>%  summarize(n = n())

```


In this code chunk, we add a time variable, and exclude cases that have any missing values. This may need to be amended later, but should work for the moment.(9/10/21)
```{r}
coxph_df <- matching_df_all_vars %>% 
  mutate(time = case_when(is.na(trt_time) == F ~ trt_time, #time is time of bacterial infection (trt_time) if there was one
                          is.na(trt_time) == T ~ covid_days_in_hospital), # time is censoring time (days in hospital) if there wasn't an infection
         status = !is.na(trt_time)) %>% # status is F if there is not an infection ( and therefore no "treatment time", and T if there was an infection)
  filter(any(is.na(age_at_admission), is.na(sex), is.na(adt_status), is.na(covid_visits_start_date), is.na(combined_race_ethnicity), is.na(bmi), is.na(dx_ckd), is.na(dx_dm), is.na(dx_htn), is.na(dx_cad), is.na(dx_hrt_failure), is.na(time), is.na(status)) == F) 

# filter out anything with a missing value for any of our predictor variables, or with a missing value for the status or time value, for the time being.
```

Checkpoint: did I correctly set status to be T for people who had infections, F otherwise?
```{r}
coxph_df %>% 
  ungroup() %>% 
  summarize(prop_status_1 = mean(status),
            n_with_status_1 = sum(status),
            prop_covid_bacterial_same_admission = mean(covid_and_bacterial_same_admission),
            n_covid_bacterial_same_admission = sum(covid_and_bacterial_same_admission))
```
9/10/21: These numbers should be the same, and yet they are slightly different! Need to look into why. Why do we have status = 1 for some people who are NOT listed as having covid and bacterial infections in the same admission? Look into how each variable was created to figure out. Not a big impediment, but need to figure out.

## Set up cox model:
```{r}
coxph_model <- coxph(Surv(time, status) ~ age_at_admission + sex + adt_status + covid_visits_start_date + combined_race_ethnicity + bmi + dx_dm + dx_htn + dx_cad +dx_hrt_failure,
               data = coxph_df)

coxph_model %>% 
  gtsummary::tbl_regression(exp = TRUE, estimate_fun = function(x) style_ratio(x, digits = 4))
# Of course I should add quite a few other variables here - however, I think for the moment, I'll leave like this just to make sure I can set this up to run properly. 

propensity <- predict(coxph_model, type = "risk", x = coxph_df)
```


9/1/21: notes on things still to do:
- adapt variables to have appropriate reference groups.
- why doesn't propensity come out as as long as the coxph_model dataframe? Are there a bunch missing all their variables or soemthing????
    Update 9/2: had to do with missing values. updating to napredict might work.....

## Matching time!

Set up "risk set" dataframe, which will include everyone for starters. This will be revised each time matching happens.
```{r}
riskset <- tibble(coxph_df, propensity) %>% 
  select(mrn, status, propensity, time, covid_days_in_hospital)
```

Set up dataframe of infection times with space for output:
```{r}
matches <- riskset %>% 
  filter(status == 1) %>% 
  select(mrn, propensity, time, status, covid_days_in_hospital) %>% 
  arrange(time) %>% 
  mutate(ctrl_mrn = NA, ctrl_propensity = NA, ctrl_time = NA, ctrl_status = NA, ctrl_covid_days_in_hospital = NA)
```

Now run the matching process:
```{r}
for(i in 1:nrow(matches)) {
  # pick control among eligible riskset based on propensity
  temp <- riskset %>% 
    filter(time >= matches$time[i], # riskset only includes those still at risk
           mrn != matches$mrn[i]) %>% # and not infection we're trying to match
    mutate(propensity_difference = abs(propensity - matches$propensity[i])) %>% 
    filter(propensity_difference == min(propensity_difference))
      # keep control with closest risk to the infection we're matching
  
  # plug info about control into matches df
  matches$ctrl_mrn[i] <- temp$mrn[1]
  matches$ctrl_propensity[i] <- temp$propensity[1]
  matches$ctrl_time[i] <- temp$time[1]
  matches$ctrl_status[i] <- temp$status[1]
  matches$ctrl_covid_days_in_hospital[i] <- temp$covid_days_in_hospital[1]
  
  # save new riskset excluding the control that was just matched 
  riskset <- riskset %>% filter(mrn!=temp$mrn[1])
}
```


For now, we've included infected people as potential controls if they're still in the risk set, but this could be easily changed. 
Assess how often people with infections got selected as controls:
```{r}
matches %>% 
  summarize(n_infected_controls = sum(ctrl_status))
```
Infected people were selected as controls in 22 cases. This is higher than would be seen at random, but is consistent with literature (at least in that "later exposed" ppl are selected as controls more often than random), because presumably these individuals have commonalities with the infected individuals they serve as controls for.

# Make some comparisons in the datasets and between matches:

Set up dataset with all data and the matched individuals only
```{r}
# make a list of ids of the people who were matched
matched_ppl <- c(unlist(matches$mrn), unlist(matches$ctrl_mrn))

# make dataset of matching ppl only
matched_ppl_df <- coxph_df %>% filter(mrn %in% matched_ppl)
```

Check covariate balance:
```{r}
# compare baseline characteristics in the unmatched sample:
example_df %>% 
  group_by(status) %>% 
  summarize(mean_cov1 = mean(cov1),
            sd_cov1 = sd(cov1),
            mean_cov2 = mean(cov2),
            sd_cov2 = sd(cov2),
            mean_cov3 = mean(cov3),
            sd_cov3 = sd(cov3))

# compare baseline characteristics in the matched sample:
matched_ppl_df %>% 
  group_by(status) %>% 
  summarize(mean_cov1 = mean(cov1),
            sd_cov1 = sd(cov1),
            mean_cov2 = mean(cov2),
            sd_cov2 = sd(cov2),
            mean_cov3 = mean(cov3),
            sd_cov3 = sd(cov3))

# following Hade et al, look at covariate impact on treatment hazard before and after matching:
# before matching:
coxph_model

#after matching:
coxph_model_matched <- coxph(Surv(time, status) ~ cov1 + cov2 + cov3, data = matched_ppl_df)
coxph_model_matched
```

Notes: more resources on checking balance:
https://cran.r-project.org/web/packages/MatchIt/vignettes/assessing-balance.html
https://onlinelibrary-wiley-com.ezproxy.cul.columbia.edu/doi/epdf/10.1002/sim.3697

In this very small example, there was already a pretty good balance between groups in the 
covariates before matchin, and comparable balance after matching. I don't expect this to be the 
case with the real data.

# Look at results:

```{r}
# make subsets of data to use for t-tests (there's surely a quicker way, but this should work)
infected <- matches %>% select(mrn:covid_days_in_hospital)
all_uninfected <- coxph_df %>% filter(status == F)
controls <- matches %>% select(ctrl_mrn:ctrl_covid_days_in_hospital)
  

# unmatched sample:
t.test(x = infected$covid_days_in_hospital, y = all_uninfected$covid_days_in_hospital) 
# matched sample:
t.test(x = infected$covid_days_in_hospital, y = controls$ctrl_covid_days_in_hospital)

# i think we're actually supposed to use a paired sample t-test (following watson et al for this)
matches %>% mutate(diff = covid_days_in_hospital - ctrl_covid_days_in_hospital) %>% 
  pull(diff) %>% # pick 
  t.test()
```

Plot results:
```{r}
matches %>% 
  ggplot(aes(x = covid_days_in_hospital)) +
  geom_density(color = "blue") +
  geom_density(aes(x = ctrl_covid_days_in_hospital), color = "red") +
  labs(title = "Length of covid admissions after preliminary matching", 
       x = "Length of stay (days)")
```

## Now, consider only never-infected people as controls:

Set up "risk set" dataframe, which will include ONLY UNINFECTED people
```{r}
riskset2 <- tibble(coxph_df, propensity) %>% 
  select(mrn, status, propensity, time, covid_days_in_hospital) %>% 
  filter(status == F)

infected2 <- tibble(coxph_df, propensity) %>% 
  select(mrn, status, propensity, time, covid_days_in_hospital) %>% 
  filter(status == T)
```

Set up dataframe of infection times with space for output:
```{r}
matches2 <- infected2 %>% 
  select(mrn, propensity, time, status, covid_days_in_hospital) %>% 
  arrange(time) %>% 
  mutate(ctrl_mrn = NA, ctrl_propensity = NA, ctrl_time = NA, ctrl_status = NA, ctrl_covid_days_in_hospital = NA)
```

Now run the matching process:
```{r}
for(i in 1:nrow(matches2)) {
  # pick control among eligible riskset based on propensity
  temp <- riskset2 %>% 
    filter(time >= matches2$time[i], # riskset only includes those still at risk
           mrn != matches2$mrn[i]) %>% # and not infection we're trying to match
    mutate(propensity_difference = abs(propensity - matches2$propensity[i])) %>% 
    filter(propensity_difference == min(propensity_difference))
      # keep control with closest risk to the infection we're matching
  
  # plug info about control into matches df
  matches2$ctrl_mrn[i] <- temp$mrn[1]
  matches2$ctrl_propensity[i] <- temp$propensity[1]
  matches2$ctrl_time[i] <- temp$time[1]
  matches2$ctrl_status[i] <- temp$status[1]
  matches2$ctrl_covid_days_in_hospital[i] <- temp$covid_days_in_hospital[1]
  
  # save new riskset excluding the control that was just matched 
  riskset2 <- riskset2 %>% filter(mrn!=temp$mrn[1])
}
```

## Look at results using matches2:

# Look at results:

```{r}
# make subsets of data to use for t-tests (there's surely a quicker way, but this should work)
# infected <- matches %>% select(mrn:covid_days_in_hospital)
# all_uninfected <- coxph_df %>% filter(status == F)
controls2 <- matches2 %>% select(ctrl_mrn:ctrl_covid_days_in_hospital) 
  

# unmatched sample:
t.test(x = infected$covid_days_in_hospital, y = all_uninfected$covid_days_in_hospital)

# matched sample:
t.test(x = infected$covid_days_in_hospital, y = controls2$ctrl_covid_days_in_hospital)

# i think we're actually supposed to use a paired sample t-test (following watson et al for this)
matches2 %>% mutate(diff = covid_days_in_hospital - ctrl_covid_days_in_hospital) %>% 
  pull(diff) %>% # pick 
  t.test()
```

Plot results:
```{r}
matches2 %>% 
  ggplot(aes(x = covid_days_in_hospital)) +
  geom_density(color = "blue") +
  geom_density(aes(x = ctrl_covid_days_in_hospital), color = "red") +
  labs(title = "Length of admissions after prelim matching - only uninfected controls", 
       x = "Length of stay (days)")
```


